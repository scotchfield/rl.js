<!DOCTYPE html>

<html>
<head>
  <title>rl.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>rl.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>rl.js: A JavaScript library to build browser-based roguelikes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> rl = (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
<span class="hljs-pi">    'use strict'</span>;

    <span class="hljs-keyword">var</span> rl = {}, tiles = [],
        canvas = <span class="hljs-literal">false</span>, ctx = <span class="hljs-literal">false</span>,
        keydown_callbacks = [],
        tiles_index = {},
        blocking = {},

    images = {},</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>A collection of options can be passed to create. These options are
used to specify the width and height (in tiles) of the new canvas,
the tile size, and so on. The defaults are listed here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    options = {
        width: <span class="hljs-number">40</span>,
        height: <span class="hljs-number">25</span>,
        tileWidth: <span class="hljs-number">24</span>,
        tileHeight: <span class="hljs-number">24</span>,
        backgroundColor: <span class="hljs-string">'#000000'</span>,
        foregroundColor: <span class="hljs-string">'#ffffff'</span>,
        font: <span class="hljs-string">'20pt monospace'</span>,
        fontFillStyle: <span class="hljs-string">'#ffffff'</span>,
        textAlign: <span class="hljs-string">'center'</span>,
        imageSmoothingEnabled: <span class="hljs-literal">false</span>,
        baseAlpha: <span class="hljs-number">0.3</span>,
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Used by isKey to detect keypresses. isKey expects each of the
properties provided to match. For example, in the code below,
matching keyCode 65 will match ‘a’ and ‘A’.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.key = {
        left: {keyCode: <span class="hljs-number">37</span>},
        up: {keyCode: <span class="hljs-number">38</span>},
        right: {keyCode: <span class="hljs-number">39</span>},
        down: {keyCode: <span class="hljs-number">40</span>},
        <span class="hljs-number">0</span>: {keyCode: <span class="hljs-number">48</span>},
        <span class="hljs-number">1</span>: {keyCode: <span class="hljs-number">49</span>},
        <span class="hljs-number">2</span>: {keyCode: <span class="hljs-number">50</span>},
        <span class="hljs-number">3</span>: {keyCode: <span class="hljs-number">51</span>},
        <span class="hljs-number">4</span>: {keyCode: <span class="hljs-number">52</span>},
        <span class="hljs-number">5</span>: {keyCode: <span class="hljs-number">53</span>},
        <span class="hljs-number">6</span>: {keyCode: <span class="hljs-number">54</span>},
        <span class="hljs-number">7</span>: {keyCode: <span class="hljs-number">55</span>},
        <span class="hljs-number">8</span>: {keyCode: <span class="hljs-number">56</span>},
        <span class="hljs-number">9</span>: {keyCode: <span class="hljs-number">57</span>},
        a: {keyCode: <span class="hljs-number">65</span>},
        b: {keyCode: <span class="hljs-number">66</span>},
        c: {keyCode: <span class="hljs-number">67</span>},
        d: {keyCode: <span class="hljs-number">68</span>},
        e: {keyCode: <span class="hljs-number">69</span>},
        f: {keyCode: <span class="hljs-number">70</span>},
        g: {keyCode: <span class="hljs-number">71</span>},
        h: {keyCode: <span class="hljs-number">72</span>},
        i: {keyCode: <span class="hljs-number">73</span>},
        j: {keyCode: <span class="hljs-number">74</span>},
        k: {keyCode: <span class="hljs-number">75</span>},
        l: {keyCode: <span class="hljs-number">76</span>},
        m: {keyCode: <span class="hljs-number">77</span>},
        n: {keyCode: <span class="hljs-number">78</span>},
        o: {keyCode: <span class="hljs-number">79</span>},
        p: {keyCode: <span class="hljs-number">80</span>},
        q: {keyCode: <span class="hljs-number">81</span>},
        r: {keyCode: <span class="hljs-number">82</span>},
        s: {keyCode: <span class="hljs-number">83</span>},
        t: {keyCode: <span class="hljs-number">84</span>},
        u: {keyCode: <span class="hljs-number">85</span>},
        v: {keyCode: <span class="hljs-number">86</span>},
        w: {keyCode: <span class="hljs-number">87</span>},
        x: {keyCode: <span class="hljs-number">88</span>},
        y: {keyCode: <span class="hljs-number">89</span>},
        z: {keyCode: <span class="hljs-number">90</span>},
        less_than: {keyCode: <span class="hljs-number">188</span>, shiftKey: <span class="hljs-literal">true</span>},
        greater_than: {keyCode: <span class="hljs-number">190</span>, shiftKey: <span class="hljs-literal">true</span>},
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Tiles are represented as objects, and have two primary properties:
render and blocking. The render property identifies a function that
draws the tile to the specified (x, y) location. The blocking
property is used to prevent movement.</p>

            </div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>todo: need another property to block movement but allow light/sight.</p>

            </div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>A solid white square that blocks typical character movement.
The object returned from rl.TileBlocking can be used as a template
for new blocking tiles (see TileWall for an example).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.TileBlocking = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> rl.TileBlocking)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> rl.TileBlocking();
        }
    };
    rl.TileBlocking.prototype.style = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">'#ffffff'</span> };
    rl.TileBlocking.prototype.blocking = <span class="hljs-literal">true</span>;
    rl.TileBlocking.prototype.render = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y)</span> </span>{
        rl.style(<span class="hljs-keyword">this</span>.style()).square(x, y);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>By using TileBlocking as a template and modifying the style
property, we can enable simple coloured walls.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.TileWall = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(colour)</span> </span>{
        <span class="hljs-keyword">var</span> that = rl.TileBlocking();

        <span class="hljs-keyword">if</span> (colour !== <span class="hljs-literal">undefined</span>) {
            that.style = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> colour; }
        }

        <span class="hljs-keyword">return</span> that;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Since we can cache images using rl.js, we can use TileBlocking as a
template and render images instead of blank squares.
image_id: the key associated with the cached image
(x, y): the (x, y) coordinates in image_id where the tile begins
(width, height): the size of the source tile in image_id</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.TileImg = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(t)</span> </span>{
        <span class="hljs-keyword">var</span> that = rl.TileBlocking();

        that.image_id = t.id;
        that.image_x = t.x;
        that.image_y = t.y;
        that.image_w = t.w;
        that.image_h = t.h;

        that.render = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y)</span> </span>{
            <span class="hljs-keyword">if</span> (images[that.image_id] !== <span class="hljs-literal">undefined</span>) {
                ctx.drawImage(images[that.image_id],
                              that.image_x, that.image_y,
                              that.image_w, that.image_h,
                              x * options.tileWidth, y * options.tileHeight,
                              options.tileWidth, options.tileHeight);
            }
        };

        <span class="hljs-keyword">return</span> that;
    };

    rl.TileImgFull = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(t)</span> </span>{
        <span class="hljs-keyword">var</span> that = rl.TileBlocking();

        that.image_id = t.id;
        that.image_x = t.x;
        that.image_y = t.y;
        that.image_w = t.w;
        that.image_h = t.h;
        that.scale = t.scale || <span class="hljs-number">1</span>;

        that.render = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y)</span> </span>{
            <span class="hljs-keyword">if</span> (images[that.image_id] !== <span class="hljs-literal">undefined</span>) {
                ctx.drawImage(images[that.image_id],
                              that.image_x, that.image_y,
                              that.image_w, that.image_h,
                              x * options.tileWidth, y * options.tileHeight,
                              that.image_w * that.scale,
                              that.image_h * that.scale);
            }
        };

        <span class="hljs-keyword">return</span> that;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>Just like TileImg, but toggle the blocking parameter so that
characters can walk over the square (for example, a dirt or grass tile).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.TileImgNoBlock = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(t, options)</span> </span>{
        <span class="hljs-keyword">var</span> that = rl.TileImg(t), key;

        options = options || {};

        that.blocking = <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> options) {
            <span class="hljs-keyword">if</span> (options.hasOwnProperty(key)) {
                that[key] = options[key];
            }
        }

        <span class="hljs-keyword">return</span> that;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>An invisible tile to hold the player’s entry point in a map.
Note: this is not the only way to handle player entry, but it
shows one way to hide information in the tiles.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.TilePlayerSpawn = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> rl.TilePlayerSpawn)) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> rl.TilePlayerSpawn();
        }
    };
    rl.TilePlayerSpawn.prototype.render = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y)</span> </span>{}</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Keypresses are caught by rl.js and forwarded to callbacks. Register
a callback in the game code, and each time a key is pressed, your
function(s) will be called with the appropriate event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.registerKeydown = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cb)</span> </span>{
        keydown_callbacks.push(cb);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Remove a callback from the keypress array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.unregisterKeydown = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cb)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = keydown_callbacks.length; i &gt;= <span class="hljs-number">0</span>; i -= <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span> (keydown_callbacks[i] === cb) {
                keydown_callbacks.splice(i, <span class="hljs-number">1</span>);
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>The actual callback used by rl.js to catch keypresses. Each time an
event occurs, iterate through the list of user-specified callbacks,
and pass the event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.keydown = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e)</span> </span>{
        keydown_callbacks.forEach(
            <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(current)</span> </span>{
                current(e);
            }
        );

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Clear the canvas using the style specified in options.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.clear = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        rl.style(options.backgroundColor);
        ctx.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, canvas.width, canvas.height);
        rl.style(options.foregroundColor);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Set the active style when drawing to the canvas. This might be a
hex colour code, rgb/rgba value, or other style information.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.style = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(c)</span> </span>{
        ctx.fillStyle = c;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>Draw a string to the canvas at the specified (x, y) tile positions.
For example, rl.style(‘#ffffff’).write(‘Hello’, 0, 0) will write the
‘Hello’ string in white letters in the top-left corner.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.write = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(s, x, y)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> s !== <span class="hljs-string">'string'</span>) {
            s = s.toString();
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; s.length; i += <span class="hljs-number">1</span>) {
            ctx.fillText(s[i],
                (x + i + <span class="hljs-number">1</span>) * options.tileWidth - <span class="hljs-number">9</span>,
                (y + <span class="hljs-number">1</span>) * options.tileWidth - <span class="hljs-number">1</span>);
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Draw a single square at the screen tile position indicated by (x, y).
Uses the last specified style().</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.square = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y)</span> </span>{
        ctx.fillRect(x * options.tileWidth, y * options.tileHeight,
                     options.tileWidth, options.tileHeight);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>rl.js retains a list of tiles that it will render when asked.
These are also used to calculate blocking, visibility, and other
qualities.</p>

            </div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Add a tile object at global position (x, y) to the internal tiles array.
If no tile is specified, use a TileBlocking object by default.</p>

            </div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>One important distinction is that tiles are specified by a world
(x, y) position when instantiated. For example, a blocking wall
may be created as rl.addTile(0, 0). This doesn’t mean that the wall
is always rendered at (0, 0). Drawing tiles later may map this to
a relative position (if the player is at (1, 1) and is centered on
the canvas, the wall will also appear near the center).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.addTile = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y, t)</span> </span>{
        <span class="hljs-keyword">var</span> tile = (t === <span class="hljs-literal">undefined</span>) ? <span class="hljs-keyword">this</span>.TileBlocking() : t;
        tiles.push({x: x, y: y, t: tile});

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Check to see if the square at (x, y) contains a blocking tile.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.canMoveTo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y)</span> </span>{
        <span class="hljs-keyword">var</span> result = <span class="hljs-literal">true</span>;
        tiles.forEach(
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(current)</span> </span>{
                <span class="hljs-keyword">if</span> (current.x === x &amp;&amp; current.y === y &amp;&amp;
                        current.t.blocking === <span class="hljs-literal">true</span>) {
                    result = <span class="hljs-literal">false</span>;
                }
            }
        );
        <span class="hljs-keyword">return</span> result;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Append the default list of options with any user-specified options.
Next, create a new canvas object and clear it. This is an internal
function called by create.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.canvas = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(opt)</span> </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> opt) {
            <span class="hljs-keyword">if</span> (opt.hasOwnProperty(k)) {
                options[k] = opt[k];
            }
        }

        canvas = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'canvas'</span>);
        ctx = canvas.getContext(<span class="hljs-string">'2d'</span>);

        canvas.width = options.width * options.tileWidth;
        canvas.height = options.height * options.tileHeight;
        <span class="hljs-keyword">this</span>.clear();

        ctx.font = options.font;
        ctx.textAlign = options.textAlign;

        ctx.imageSmoothingEnabled = options.imageSmoothingEnabled;

        <span class="hljs-keyword">return</span> canvas;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Creates a new canvas object and appends it to the DOM element specified
by the id argument.
This is the only rl.js function that must be in your game code!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.create = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(id, options)</span> </span>{
        canvas = <span class="hljs-keyword">this</span>.canvas(options);
        <span class="hljs-built_in">document</span>.getElementById(id).appendChild(canvas);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Render any tiles that we’re storing to the canvas.
x and y represent the top-left corner of the screen.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.render = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y)</span> </span>{
        tiles.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(t)</span> </span>{
            <span class="hljs-keyword">if</span> (t.x &gt;= x &amp;&amp; t.x &lt; x + options.width &amp;&amp;
                    t.y &gt;= y &amp;&amp; t.y &lt; y + options.height) {
                <span class="hljs-keyword">if</span> (options.alwaysShowTiles === <span class="hljs-literal">true</span> || t.visible !== <span class="hljs-literal">false</span>) {
                    t.t.render(t.x - x, t.y - y);
                } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t.observed === <span class="hljs-literal">true</span>) {
                    ctx.globalAlpha = options.baseAlpha;
                    t.t.render(t.x - x, t.y - y);
                    ctx.globalAlpha = <span class="hljs-number">1</span>;
                }
            }
        });

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Return the tile x-index at the center of the screen.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.cx = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(options.width / <span class="hljs-number">2</span>);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Return the tile y-index at the center of the screen.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.cy = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(options.height / <span class="hljs-number">2</span>);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>Load an image from an external source (a .png file containing tiles,
for example) and cache it inside rl.js. Must specify an id to access
it later, and an optional callback when the file is loaded.
This is an asynchronous call, so please note that the image is not
available immediately!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.loadImage = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, id, cb)</span> </span>{
        <span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> Image();
        image.src = name;
        image.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            images[id] = <span class="hljs-keyword">this</span>;
            <span class="hljs-keyword">if</span> (cb !== <span class="hljs-literal">undefined</span>) {
                cb();
            }
        };

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Populate the blocking property for quick lookup.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.updateBlocking = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        blocking = {};

        tiles.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(t)</span> </span>{
            <span class="hljs-keyword">if</span> (t.t.blocking === <span class="hljs-literal">true</span>) {
                blocking[t.x] = blocking[t.x] || {};
                blocking[t.x][t.y] = <span class="hljs-literal">true</span>;
            }
        });

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Populate tiles_index, allowing for quick lookup of tiles at a
particular (x, y) location.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.updateTilesIndex = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        tiles_index = {};

        tiles.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(t)</span> </span>{
            tiles_index[t.x] = tiles_index[t.x] || {}
            tiles_index[t.x][t.y] = tiles_index[t.x][t.y] || [];
            tiles_index[t.x][t.y].push(t.t);
        });

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Attempt to draw a line from one source tile to the other. If a line
can be drawn, the path between the two tiles is clear of obstruction.
Modified from rosettacode.org/wiki/Bitmap/Bresenham%27s_line_algorithm</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.blockedLine = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x0, y0, x1, y1)</span> </span>{
        <span class="hljs-keyword">var</span> dx = <span class="hljs-built_in">Math</span>.abs(x1 - x0), sx = x0 &lt; x1 ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>,
            dy = <span class="hljs-built_in">Math</span>.abs(y1 - y0), sy = y0 &lt; y1 ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>,
            err = (dx &gt; dy ? dx : -dy) / <span class="hljs-number">2</span>,
            err2;

        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
            <span class="hljs-keyword">if</span> (x0 === x1 &amp;&amp; y0 === y1) {
                <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-keyword">if</span> (blocking[x0][y0] === <span class="hljs-literal">true</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            }
            err2 = err;
            <span class="hljs-keyword">if</span> (err2 &gt; -dx) {
                err -= dy;
                x0 += sx;
            }
            <span class="hljs-keyword">if</span> (err2 &lt; dy) {
                err += dx;
                y0 += sy;
            }

        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Iterate through all of the tiles to determine which ones are currently
visible from the given (x, y) position.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.updateVisible = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y)</span> </span>{
        tiles.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(t)</span> </span>{
            t.visible = <span class="hljs-literal">false</span>;
            <span class="hljs-keyword">if</span> (! rl.blockedLine(x, y, t.x, t.y)) {
                t.visible = <span class="hljs-literal">true</span>;
                t.observed = <span class="hljs-literal">true</span>;
            }
        });

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Compares a keypress event with an object of expected properties. If
the event contains all of the properties specified in key, return
true, otherwise false/</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.isKey = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(e, key)</span> </span>{
        <span class="hljs-keyword">var</span> k;

        <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> key) {
            <span class="hljs-keyword">if</span> (key.hasOwnProperty(k) &amp;&amp; e[k] !== key[k]) {
                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Set the current tiles array to new_tiles. Used, for example, when
changing from one level to another.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.setTiles = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(new_tiles)</span> </span>{
        tiles = new_tiles;

        rl.updateBlocking()
            .updateTilesIndex();

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Apply the given function to each of the tiles.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.applyTiles = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(f)</span> </span>{
        tiles.forEach(f);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Call fillRect directly on the 2d canvas context.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.fillRect = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y, width, height)</span> </span>{
        ctx.fillRect(x, y, width, height);

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Set the 2d context’s globalAlpha property (drawing opacity).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.globalAlpha = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x)</span> </span>{
        x = x || <span class="hljs-number">1</span>;

        ctx.globalAlpha = x;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Return the width of the canvas, in pixels.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.canvasWidth = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> options.width * options.tileWidth;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Return the height of the canvas, in pixels.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.canvasHeight = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> options.height * options.tileHeight;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Return an array containing all of the tiles at a given (x, y) position.
Can optionally accept a tile array instead of using the tiles object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.tilesAt = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y, tile_array)</span> </span>{
        <span class="hljs-keyword">var</span> tile_return = [];

        tile_array = tile_array || tiles;

        tile_array.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(tile)</span> </span>{
            <span class="hljs-keyword">if</span> (tile.x === x &amp;&amp; tile.y === y) {
                tile_return.push(tile);
            }
        });

        <span class="hljs-keyword">return</span> tile_return;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Remove all of the tiles at a given (x, y) position.
Can optionally accept a tile array instead of using the tiles object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.removeTilesAt = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(x, y, tile_array)</span> </span>{
        <span class="hljs-keyword">var</span> i;

        tile_array = tile_array || tiles;

        <span class="hljs-keyword">for</span> (i = tile_array.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -= <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span> (tile_array[i].x === x &amp;&amp; tile_array[i].y === y) {
                tile_array.splice(i, <span class="hljs-number">1</span>);
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Iterate through the tiles array (or, optionally, a provided tile
array), and retain only the last tile at each (x, y) position that
does not have the blocking property set to false. For example, if
there are two walls at a particular position, keep only the “top”
one—the one that occurs later in the array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    rl.keepTopBlockingTiles = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(tile_array)</span> </span>{
        <span class="hljs-keyword">var</span> i, found = {}, key;

        tile_array = tile_array || tiles;

        <span class="hljs-keyword">for</span> (i = tile_array.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -= <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">if</span> (tile_array[i].blocking !== <span class="hljs-literal">false</span>) {
                key = tile_array[i].x + <span class="hljs-string">','</span> + tile_array[i].y;
                <span class="hljs-keyword">if</span> (found[key] !== <span class="hljs-literal">undefined</span>) {
                    tile_array.splice(i, <span class="hljs-number">1</span>);
                }
                found[key] = <span class="hljs-literal">true</span>;
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    };

    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'keydown'</span>, rl.keydown);

    <span class="hljs-keyword">return</span> rl;
}());</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
